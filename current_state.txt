@function.defn()
async def run_locally(input: RunCodeInput) -> RunCodeOutput:
    log.info("run_locally started", input=input)
    
    # Decide where to put the files. If not set, fall back to /tmp or /app/output
    base_output_dir = os.environ.get("LLM_OUTPUT_DIR", "/app/output")
    
    # For clarity, create a unique subfolder each run (timestamp-based):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    run_folder = os.path.join(base_output_dir, f"llm_run_{timestamp}")
    
    # Validate inputs before writing to disk
    try:
        # Validate Dockerfile content
        if not input.dockerfile or not isinstance(input.dockerfile, str):
            return RunCodeOutput(output="Error: Invalid or missing Dockerfile")
            
        # Check for dangerous Dockerfile patterns
        dangerous_patterns = [
            "--privileged",
            "-v /:/host",
            "/var/run/docker.sock",
            "chmod 777 /",
            "FROM scratch",  # Often used in container escape techniques
            "ADD http",      # Downloading external resources
            "--security-opt",  # Setting security options 
            "--cap-add=ALL",   # Adding all capabilities
            "SYS_ADMIN",       # System admin capability
        ]
        
        for pattern in dangerous_patterns:
            if pattern.lower() in input.dockerfile.lower():
                return RunCodeOutput(output=f"Error: Security violation in Dockerfile - contains forbidden pattern: {pattern}")
        
        # Create output directory
        os.makedirs(run_folder, exist_ok=True)
        
        # Write the validated Dockerfile
        dockerfile_path = os.path.join(run_folder, "Dockerfile")
        with open(dockerfile_path, "w", encoding="utf-8") as f:
            f.write(input.dockerfile)
        
        # Validate and write each file
        if not input.files or not isinstance(input.files, list):
            return RunCodeOutput(output="Error: Invalid or missing files list")
            
        for file_item in input.files:
            if not isinstance(file_item, dict) or "filename" not in file_item or "content" not in file_item:
                return RunCodeOutput(output="Error: Invalid file item format")
                
            filename = file_item["filename"]
            content = file_item["content"]
            
            # Validate filename to prevent path traversal
            if not filename or not isinstance(filename, str):
                return RunCodeOutput(output="Error: Invalid filename")
                
            # Normalize path and prevent traversal beyond run_folder
            safe_filename = os.path.normpath(filename)
            
            # Prevent absolute paths and parent directory traversal
            if safe_filename.startswith("/") or ".." in safe_filename.split(os.path.sep):
                return RunCodeOutput(output=f"Error: Path traversal attempt detected in filename: {filename}")
                
            # Create the file path inside the run folder
            file_path = os.path.join(run_folder, safe_filename)
            
            # Double-check the resolved path is within our run folder
            if not os.path.abspath(file_path).startswith(os.path.abspath(run_folder)):
                return RunCodeOutput(output=f"Error: Path traversal attempt detected for: {filename}")
                
            # Create parent directories if needed
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            
            # Write the file
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(content)
    except Exception as e:
        log.error(f"Error in file validation/writing: {str(e)}")
        return RunCodeOutput(output=f"Error: Failed to prepare files: {str(e)}")
    
    # Run docker build with timeout
    try:
        build_cmd = [
            "docker", "build",
            "--no-cache",    # Disable cache for cleaner builds
            "-t", "myapp", 
            run_folder
        ]
        
        build_process = subprocess.run(
            build_cmd,
            capture_output=True,
            text=True,
            timeout=300  # 5-minute timeout
        )
        
        if build_process.returncode != 0:
            log.warn(f"Docker build failed: {build_process.stderr}")
            return RunCodeOutput(output=f"Docker build error: {build_process.stderr}")
            
    except subprocess.TimeoutExpired:
        log.warn("Docker build timed out")
        return RunCodeOutput(output="Error: Docker build timed out after 5 minutes")
    except Exception as e:
        log.error(f"Docker build error: {str(e)}")
        return RunCodeOutput(output=f"Error: Docker build failed: {str(e)}")
    
    # Run the container with security measures
    try:
        run_cmd = [
            "docker", "run",
            "--rm",  # Remove container after it exits
            "--security-opt=no-new-privileges=true",  # Prevent privilege escalation
            "--cap-drop=ALL",  # Drop all capabilities
            "--cap-add=NET_BIND_SERVICE",  # Add only necessary capabilities
            "--memory=1g",  # Memory limit
            "--cpus=1",  # CPU limit
            "--pids-limit=100",  # Process limit to prevent fork bombs
            "--ulimit", "nofile=64:64",  # Limit open files
            "myapp"
        ]
        
        run_process = subprocess.run(
            run_cmd,
            capture_output=True,
            text=True,
            timeout=300  # 5-minute timeout
        )
        
        return RunCodeOutput(output=run_process.stdout)
        
    except subprocess.TimeoutExpired:
        log.warn("Docker run timed out")
        return RunCodeOutput(output="Error: Docker run timed out after 5 minutes")
    except Exception as e:
        log.error(f"Docker run error: {str(e)}")
        return RunCodeOutput(output=f"Error: Docker run failed: {str(e)}")