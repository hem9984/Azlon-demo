@function.defn()
async def run_locally(input: RunCodeInput) -> RunCodeOutput:
    log.info("run_locally started", input=input)
    
    # Decide where to put the files. If not set, fall back to /tmp or /app/output
    base_output_dir = os.environ.get("LLM_OUTPUT_DIR", "/app/output")
    
    # For clarity, create a unique subfolder each run (timestamp-based):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    run_folder = os.path.join(base_output_dir, f"llm_run_{timestamp}")
    os.makedirs(run_folder, exist_ok=True)
    
    # Get the absolute path of the run folder for security checks
    abs_run_folder = os.path.abspath(run_folder)
    
    # Write the Dockerfile
    dockerfile_path = os.path.abspath(os.path.join(run_folder, "Dockerfile"))
    
    # Ensure the Dockerfile path is within the run folder
    if not dockerfile_path.startswith(abs_run_folder + os.sep) and dockerfile_path != abs_run_folder:
        log.warning("Invalid Dockerfile path detected, potential path traversal")
        return RunCodeOutput(output="Error: Invalid Dockerfile path")
        
    with open(dockerfile_path, "w", encoding="utf-8") as f:
        f.write(input.dockerfile)
    
    # Write each file
    for file_item in input.files:
        # Construct the target file path
        target_path = os.path.join(run_folder, file_item["filename"])
        
        # Get the real absolute path of the target
        abs_target_path = os.path.abspath(target_path)
        
        # Check if the target path is within the run folder
        if not abs_target_path.startswith(abs_run_folder + os.sep) and abs_target_path != abs_run_folder:
            log.warning(f"Path traversal attempt detected with filename: {file_item['filename']}")
            continue
            
        # Create the directory structure if it doesn't exist
        os.makedirs(os.path.dirname(abs_target_path), exist_ok=True)
        
        # Write the file content
        with open(abs_target_path, "w", encoding="utf-8") as ff:
            ff.write(file_item["content"])
    
    # Now run docker build, connecting to Docker-in-Docker at DOCKER_HOST
    build_cmd = ["docker", "build", "-t", "myapp", run_folder]
    build_process = subprocess.run(build_cmd, capture_output=True, text=True)
    if build_process.returncode != 0:
        return RunCodeOutput(output=build_process.stderr or build_process.stdout)
    
    # Then run the container
    run_cmd = ["docker", "run", "--rm", "myapp"]
    run_process = subprocess.run(run_cmd, capture_output=True, text=True)
    if run_process.returncode != 0:
        return RunCodeOutput(output=run_process.stderr or run_process.stdout)
    
    return RunCodeOutput(output=run_process.stdout)