from restack_ai.function import function, log
from dataclasses import dataclass
import os
import openai
import json
import shutil
import subprocess
from datetime import datetime

from pydantic import BaseModel
from typing import List, Optional

from src.prompts import current_generate_code_prompt, current_validate_output_prompt

openai.api_key = os.environ.get("OPENAI_KEY")

# Use the OpenAI Python SDK's structured output parsing
from openai import OpenAI
client = OpenAI(api_key=openai.api_key)

class FileItem(BaseModel):
    filename: str
    content: str

    class Config:
        extra = "forbid"
        schema_extra = {
            "type": "object",
            "properties": {
                "filename": {"type": "string"},
                "content": {"type": "string"}
            },
            "required": ["filename", "content"],
            "additionalProperties": False
        }

class GenerateCodeSchema(BaseModel):
    dockerfile: str
    files: List[FileItem]
    
    class Config:
        extra = "forbid"
        schema_extra = {
            "type": "object",
            "properties": {
                "dockerfile": {"type": "string"},
                "files": {
                    "type": "array",
                    "items": {"$ref": "#/$defs/FileItem"}
                }
            },
            "required": ["dockerfile", "files"],
            "additionalProperties": False,
            "$defs": {
                "FileItem": {
                    "type": "object",
                    "properties": {
                        "filename": {"type": "string"},
                        "content": {"type": "string"}
                    },
                    "required": ["filename", "content"],
                    "additionalProperties": False
                }
            }
        }

class ValidateOutputSchema(BaseModel):
    result: bool
    dockerfile: Optional[str] = None
    files: Optional[List[FileItem]] = None
    
    class Config:
        extra = "forbid"
        schema_extra = {
            "type": "object",
            "properties": {
                "result": {"type": "boolean"},
                "dockerfile": {
                    "anyOf": [
                        {"type": "string"},
                        {"type": "null"}
                    ]
                },
                "files": {
                    "anyOf": [
                        {
                            "type": "array",
                            "items": {"$ref": "#/$defs/FileItem"}
                        },
                        {"type": "null"}
                    ]
                }
            },
            "required": ["result", "dockerfile", "files"],
            "additionalProperties": False,
            "$defs": {
                "FileItem": {
                    "type": "object",
                    "properties": {
                        "filename": {"type": "string"},
                        "content": {"type": "string"}
                    },
                    "required": ["filename", "content"],
                    "additionalProperties": False
                }
            }
        }

def validate_security(dockerfile: str, files: list) -> dict:
    """
    Validate security of Dockerfile and file contents.
    Returns a dict with success flag and any security issues found.
    """
    # Define security blocklists
    dockerfile_blocklist = [
        "ADD http", "ADD ftp", "ADD https",  # Remote URLs in ADD can download malicious content
        "--privileged", "--net=host",         # Privileged mode and host network
        "/etc/passwd", "/etc/shadow",         # Sensitive files
        "chmod 777", "chmod -R 777",          # Overly permissive permissions
        "rm -rf /", "rm -rf /*",              # Destructive commands
        "curl | bash", "wget | bash",         # Pipe to shell patterns
    ]
    
    code_blocklist = [
        "os.system", "subprocess.call", "subprocess.run", "subprocess.Popen", 
        "eval(", "exec(", 
        "__import__('os')", 
        "pty.spawn", "pty.fork",
        "socket.connect", 
        "open('/etc", "open('/root", "open('/var",
        "os.path.join('/', ", "os.makedirs('/'",
        "base64.b64decode", "pickle.loads",
    ]
    
    security_issues = []
    
    # Check Dockerfile for security issues
    for pattern in dockerfile_blocklist:
        if pattern in dockerfile:
            security_issues.append(f"Dockerfile contains potentially unsafe pattern: {pattern}")
    
    # Verify using the correct base image
    if not dockerfile.strip().startswith("FROM python:3.10-slim"):
        security_issues.append("Dockerfile must use 'FROM python:3.10-slim' as the base image")
    
    # Check each file for security issues
    for file_item in files:
        filename = file_item['filename']
        content = file_item['content']
        
        # Check for path traversal attempts
        if filename.startswith('/') or '..' in filename:
            security_issues.append(f"Invalid filename path: {filename}")
        
        # Check for potentially dangerous code patterns
        for pattern in code_blocklist:
            if pattern in content:
                security_issues.append(f"File {filename} contains potentially unsafe pattern: {pattern}")
    
    # Return results
    if security_issues:
        return {
            "passed": False,
            "issues": security_issues
        }
    else:
        return {
            "passed": True,
            "issues": []
        }

@dataclass
class GenerateCodeInput:
    user_prompt: str
    test_conditions: str

@dataclass
class GenerateCodeOutput:
    dockerfile: str
    files: list

@function.defn()
async def generate_code(input: GenerateCodeInput) -> GenerateCodeOutput:
    log.info("generate_code started", input=input)

    # Create an enhanced prompt with security guidelines
    enhanced_prompt = current_generate_code_prompt.format(
        user_prompt=input.user_prompt,
        test_conditions=input.test_conditions
    )

    # Add explicit security instructions to the system message
    system_message = """You are an autonomous coding assistant agent. Generate complete code that will run.
    IMPORTANT SECURITY CONSTRAINTS:
    - Only use the specified base image: FROM python:3.10-slim
    - Do not generate code that could be used maliciously
    - Do not include commands for network access outside the application
    - Do not use dangerous functions like eval(), exec(), os.system(), subprocess.call()
    - Do not include code to download or execute external code
    - Ensure proper input validation for all user inputs
    - Use safe APIs and libraries
    - Do not attempt to access system files or directories outside the application
    """

    completion = client.beta.chat.completions.parse(
        model="gpt-4o-2024-08-06",
        messages=[
            {"role": "system", "content": system_message},
            {"role": "user", "content": enhanced_prompt}
        ],
        response_format=GenerateCodeSchema
    )

    result = completion.choices[0].message
    if result.refusal:
        raise RuntimeError("Model refused to generate code.")
    data = result.parsed

    files_list = [{"filename": f.filename, "content": f.content} for f in data.files]

    # Validate security before returning
    security_validation = validate_security(data.dockerfile, files_list)
    if not security_validation["passed"]:
        issue_list = "\n".join(security_validation["issues"])
        raise RuntimeError(f"Generated code failed security validation:\n{issue_list}")

    return GenerateCodeOutput(dockerfile=data.dockerfile, files=files_list)


@dataclass
class RunCodeInput:
    dockerfile: str
    files: list

@dataclass
class RunCodeOutput:
    output: str

@function.defn()
async def run_locally(input: RunCodeInput) -> RunCodeOutput:
    log.info("run_locally started", input=input)
    
    # Validate security before proceeding
    security_validation = validate_security(input.dockerfile, input.files)
    if not security_validation["passed"]:
        issue_list = "\n".join(security_validation["issues"])
        return RunCodeOutput(output=f"Security validation failed:\n{issue_list}")
    
    # Decide where to put the files. If not set, fall back to /tmp or /app/output
    base_output_dir = os.environ.get("LLM_OUTPUT_DIR", "/app/output")
    
    # For clarity, create a unique subfolder each run (timestamp-based):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    run_folder = os.path.join(base_output_dir, f"llm_run_{timestamp}")
    os.makedirs(run_folder, exist_ok=True)
    
    # Write the Dockerfile
    dockerfile_path = os.path.join(run_folder, "Dockerfile")
    with open(dockerfile_path, "w", encoding="utf-8") as f:
        f.write(input.dockerfile)
    
    # Write each file with path safety checks
    for file_item in input.files:
        filename = file_item["filename"]
        content = file_item["content"]
        
        # Additional path safety check
        if filename.startswith('/') or '..' in filename:
            return RunCodeOutput(output=f"Security error: Invalid filename path {filename}")
        
        file_path = os.path.join(run_folder, filename)
        
        # Ensure the path is within the run_folder (no directory traversal)
        norm_file_path = os.path.normpath(file_path)
        if not norm_file_path.startswith(run_folder):
            return RunCodeOutput(output=f"Security error: Path traversal attempt detected for {filename}")
        
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        with open(file_path, "w", encoding="utf-8") as ff:
            ff.write(content)
    
    # Now run docker build, connecting to Docker-in-Docker at DOCKER_HOST
    try:
        build_cmd = ["docker", "build", "-t", "myapp", run_folder]
        build_process = subprocess.run(build_cmd, capture_output=True, text=True, timeout=300)  # 5 minute timeout
        if build_process.returncode != 0:
            return RunCodeOutput(output=build_process.stderr or build_process.stdout)
    except subprocess.TimeoutExpired:
        return RunCodeOutput(output="Docker build timed out after 5 minutes")
    
    # Then run the container with security constraints
    try:
        run_cmd = [
            "docker", "run", 
            "--rm",                           # Remove container after execution
            "--read-only",                    # Make filesystem read-only except where volumes mounted
            "--cap-drop=ALL",                 # Drop all capabilities
            "--security-opt=no-new-privileges", # Prevent privilege escalation
            "--network=none",                 # No network access
            "--memory=512m",                  # Memory limit
            "--cpus=1.0",                     # CPU limit
            "--pids-limit=100",               # Process limit
            "--tmpfs", "/tmp:size=64m",       # Temporary filesystem
            "myapp"
        ]
        
        run_process = subprocess.run(run_cmd, capture_output=True, text=True, timeout=300)  # 5 minute timeout
        if run_process.returncode != 0:
            return RunCodeOutput(output=run_process.stderr or run_process.stdout)
        
        return RunCodeOutput(output=run_process.stdout)
    except subprocess.TimeoutExpired:
        return RunCodeOutput(output="Container execution timed out after 5 minutes")


@dataclass
class ValidateOutputInput:
    dockerfile: str
    files: list
    output: str
    test_conditions: str

@dataclass
class ValidateOutputOutput:
    result: bool
    dockerfile: Optional[str] = None
    files: Optional[list] = None

@function.defn()
async def validate_output(input: ValidateOutputInput) -> ValidateOutputOutput:
    log.info("validate_output started", input=input)

    files_str = json.dumps(input.files, indent=2)

    validation_prompt = current_validate_output_prompt.format(
        test_conditions=input.test_conditions,
        dockerfile=input.dockerfile,
        files_str=files_str,
        output=input.output
    )

    completion = client.beta.chat.completions.parse(
        model="gpt-4o-2024-08-06",
        messages=[
            {"role": "system", "content": "You are an iteration of an autonomous coding assistant agent. If you change any files, provide complete file content replacements. Append a brief explanation at the bottom of readme.md about what you tried."},
            {"role": "user", "content": validation_prompt}
        ],
        response_format=ValidateOutputSchema
    )

    result = completion.choices[0].message
    if result.refusal:
        return ValidateOutputOutput(result=False)

    data = result.parsed
    updated_files = None
    updated_dockerfile = data.dockerfile
    
    if data.files is not None:
        updated_files = [{"filename": f.filename, "content": f.content} for f in data.files]
        
        # Validate security of any updated files and dockerfile
        security_validation = validate_security(
            updated_dockerfile or input.dockerfile, 
            updated_files
        )
        if not security_validation["passed"]:
            issue_list = "\n".join(security_validation["issues"])
            log.error(f"Security validation failed for LLM-suggested changes: {issue_list}")
            # Return false but no changes to trigger retry
            return ValidateOutputOutput(result=False)

    return ValidateOutputOutput(result=data.result, dockerfile=updated_dockerfile, files=updated_files)